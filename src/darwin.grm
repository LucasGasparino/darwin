%name Darwin;

%defs (
    fun insere(hm,n,"int") = AtomMap.insert(hm, n, Grammar.Int_ 0)
      | insere(hm,n,"string") = AtomMap.insert(hm, n, Grammar.String_ "")
      | insere(hm,n,"float") = AtomMap.insert(hm, n, Grammar.Float_ 0.0)
      | insere(hm,n,_) = AtomMap.insert(hm, n, Grammar.Boolean_ false)
    
    fun getInt x = (Grammar.extractInt x)
    
    fun getVar v = AtomMap.appi (fn (k,w) => print (
        let val _ = print(Atom.toString k) 
            val _ = "oi"
            val _ = print (Grammar.show w)
        in 
            ""
        end)) v
);

%tokens
    : KW_let ("let") | KW_in ("in") | KW_title ("title") 
    | ID of string | NUM of Int.int
    | EQ ("=") | PLUS ("+")
    | TIMES ("*") | MINUS ("-")
    | LP ("(") | RP (")")
    | SPACE (" ")
    | KW_variables ("variables") | SEMI | TIPO of string
    | KW_comands ("commands") | STR of string | KW_Print ("print")
    | KW_endvars ("end variables") | KW_terminate ("terminate")
    ;
%keywords
    KW_variables,
    KW_title,
    KW_comands,
    KW_endvars,
    KW_terminate
    ;

%refcell v : (Grammar.tipo_primitivo) AtomMap.map = (AtomMap.empty);
%refcell ps : string list = (nil);

program(d)
    : KW_title STR SEMI
      KW_variables
      variables
      KW_comands
      commands => ()
    ;
commands
    : (prints | assign)* KW_terminate => ((fn(_) => ()) SR)   
    ;
assign
    : ID EQ expr SEMI => (v := Grammar.updateHt(!v,Atom.atom ID,expr))
    ;
expr
    : exp_arit => (Grammar.Int_ exp_arit)
    ;
prints
   :  KW_Print LP STR RP SEMI => ( ps := (STR::(!ps)) )
   |  KW_Print LP ID RP SEMI => (
        let 
            val k = Grammar.show (valOf (AtomMap.find (!v, Atom.atom ID)))
        in 
            ps := k::(!ps)
        end
      ) 
   ;
exp_arit
    : addExp
    ;
addExp
    : multExp ("+" multExp)*
        => ( List.foldr op+ 0 (multExp::SR) )
    ;
multExp
    : prefixExp ("*" prefixExp)*
        => ( List.foldr op* 1 (prefixExp::SR) )
    ;
prefixExp
    : atomicExp
    | "-" prefixExp
        => ( ~prefixExp )
    ;
atomicExp
    : ID => ( getInt (valOf(AtomMap.find (!v, Atom.atom ID))) )
    | NUM
    | "(" exp_arit ")"
    ;
variables
    : (declaration)* KW_endvars => ((fn(_) => ()) SR)
    ;
declaration
    : TIPO ID SEMI => (v:=insere(!v,Atom.atom ID,Atom.toString(Atom.atom TIPO)))
    ;
