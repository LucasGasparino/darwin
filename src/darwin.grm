%name Darwin;

%defs (
    fun insere(hm,n,"int") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Int_ 0))
      | insere(hm,n,"string") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.String_ ""))
      | insere(hm,n,"float") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Float_ 0.0))
      | insere(hm,n,_) = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Boolean_ false))
    
    fun getInt x = (Grammar.extractInt x)
    fun getFloat x = (Grammar.extractFloat x)
    
    fun exprTypes e1 e2 = (Grammar.typeof e1) = (Grammar.typeof e2)
    
    fun getVar v = AtomMap.appi (fn (k,w) => print (
        let val _ = print(Atom.toString k) 
            val _ = "oi"
            val _ = print (Grammar.show w)
        in 
            ""
        end)) v
);

%tokens
    : KW_let ("let") | KW_in ("in") | KW_title ("title") 
    | ID of string | NUM of Int.int | REAL of Real.real
    | EQ ("=") | PLUS ("+") | DOT (".")
    | TIMES ("*") | DIV("/") | MINUS ("-")
    | LP ("(") | RP (")")
    | SPACE (" ")
    | KW_variables ("variables") | SEMI | TIPO of string
    | KW_comands ("commands") | STR of string | KW_Print ("print")
    | KW_endvars ("end variables") | KW_terminate ("terminate")
    ;
%keywords
    KW_variables,
    KW_title,
    KW_comands,
    KW_endvars,
    KW_terminate
    ;

%refcell v : (Grammar.tipo) AtomMap.map = (AtomMap.empty);
%refcell ps : string list = (nil);

program(d)
    : KW_title STR SEMI
      KW_variables
      variables
      KW_comands
      commands => ()
    ;
commands
    : (prints | assign)* KW_terminate => ((fn(_) => ()) SR)   
    ;
assign
    : ID EQ expr SEMI => (v := Grammar.updateHt(!v,Atom.atom ID,expr))
    ;
expr
    : exp_arit => (exp_arit)
    ;
prints
   :  KW_Print LP STR RP SEMI => ( ps := (STR::(!ps)) )
   |  KW_Print LP ID RP SEMI => (
        let 
            val k = Grammar.show (valOf (AtomMap.find (!v, Atom.atom ID)))
        in 
            ps := k::(!ps)
        end
      ) 
   ;
exp_arit
    : %try addExp 
    | %try atomicExp
    ;
addExp
    : %try multExp PLUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("+",multExp1,multExp2))
    | %try multExp MINUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("-",multExp1,multExp2))
    ;
multExp
    : %try prefixExp TIMES prefixExp %where (exprTypes prefixExp1 prefixExp2) 
        => ( Grammar.oper("*",prefixExp1,prefixExp2) )
    | %try atomicExp
    ;
prefixExp
    : atomicExp
    | "-" prefixExp
        => ( Grammar.oper("neg",prefixExp,prefixExp) )
    ;
atomicExp
    : ID => (valOf(AtomMap.find (!v, Atom.atom ID))) 
    | NUM => (Grammar.Primitivo (Grammar.Int_ NUM))
    | REAL => (Grammar.Primitivo (Grammar.Float_ REAL))
    | "(" exp_arit ")"
    ;
variables
    : (declaration)* KW_endvars => ((fn(_) => ()) SR)
    ;
declaration
    : TIPO ID SEMI => (v:=insere(!v,Atom.atom ID,Atom.toString(Atom.atom TIPO)))
    ;