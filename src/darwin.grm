%name Darwin;

%defs (
    fun insere(hm,n,"int") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Int_ 0))
      | insere(hm,n,"string") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.String_ ""))
      | insere(hm,n,"float") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Float_ 0.0))
      | insere(hm,n,_) = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Boolean_ false))
    
    fun getInt x = (Grammar.extractInt x)
    fun getFloat x = (Grammar.extractFloat x)
    fun getBool x = (Grammar.extractBool x)
    fun getList x = (Grammar.extractList x)
    
    fun exprTypes e1 e2 = (Grammar.typeof e1) = (Grammar.typeof e2)
    fun isType e1 t = (Grammar.typeof e1) = t
    
    fun getVar v = AtomMap.appi (fn (k,w) => print (
        let val _ = print(Atom.toString k) 
            val _ = "oi"
            val _ = print (Grammar.show w)
        in 
            ""
        end)) v
);

%tokens
    : KW_let ("let") | KW_in ("in") | KW_title ("title") | SSTRING of (string list)
    | ID of string | NUM of Int.int | REAL of Real.real | SINT of (Int.int list)
    | EQ ("=") | PLUS ("+") | DOT (".") | EEQ ("==") | SFLOAT of (Real.real list)
    | TIMES ("*") | DIV("/") | MINUS ("-") | COMMA(",") | SBOOL of (Bool.bool list)
    | LP ("(") | RP (")") | BOOL of bool | AND ("&&") | OR ("||") | NOT("!")
    | SPACE (" ") | GT(">") | LT("<") | LEQ("<=") | GEQ(">=") | NEQ("!=")
    | KW_variables ("variables") | SEMI | TIPO of string
    | KW_comands ("commands") | STR of string | KW_Print ("print")
    | KW_endvars ("end variables") | KW_terminate ("terminate")
    | KW_SUM ("sum") | KW_PROD ("prod") | EMPTY ("{}") 
    | KW_IF("if") | KW_THEN("then") | KW_ELSE("else") | KW_WHILE("while")
    | KW_DO("do") | KW_END("end") | KW_TOSTRING ("toString") | KW_MEAN("mean")
    | KW_CORR("correlation") | KW_MEDIAN("median") | KW_STDEV("stdDeviation")
    | KW_VAR("variance") | KW_GET("get") | KW_COV("covariance")
    | KW_LINREG("linearRegression") | TUPLE of Grammar.tipo
    ;
%keywords
    KW_variables,
    KW_title,
    KW_comands,
    KW_endvars,
    KW_terminate,
    KW_IF,
    KW_THEN,
    KW_ELSE,
    KW_WHILE,
    KW_DO,
    KW_END,
    KW_PROD,
    KW_SUM,
    KW_TOSTRING,
    KW_MEAN,
    KW_CORR,
    KW_MEDIAN,
    KW_STDEV,
    KW_VAR,
    KW_GET,
    KW_COV,
    KW_LINREG
    ;

%refcell v : (Grammar.tipo) AtomMap.map = (AtomMap.empty);
%refcell ts : string AtomMap.map = (AtomMap.empty);
%refcell ps : string list = (nil);

program(d)
    : KW_title STR SEMI
      KW_variables
      variables
      KW_comands
      commands => ()
    ;
commands
    : prints commands? => ()
    | assign commands?  => ()   
    | conditional => ()
    ;
assign
    : ID EQ expr SEMI %where (AtomMap.inDomain(!v,Atom.atom ID)
                        andalso (isType expr (valOf (AtomMap.find (!ts, Atom.atom ID))))) 
                        => (v := Grammar.updateHt(!v,Atom.atom ID,expr))
    ;
expr
    : %try exp_arit => (exp_arit)
    | %try exp_bool => (exp_bool)
    | %try funcs_float => (Grammar.Primitivo (Grammar.Float_ funcs_float))
    | %try funcs_string => (Grammar.Primitivo (Grammar.String_ funcs_string))
    | %try SINT => ( Grammar.Sample (List.map (fn(x) => Grammar.Primitivo(Grammar.Int_ x)) SINT) )
    | %try SFLOAT => ( Grammar.Sample (List.map (fn(x) => Grammar.Primitivo(Grammar.Float_ x)) SFLOAT) )
    | %try SBOOL => ( Grammar.Sample (List.map (fn(x) => Grammar.Primitivo(Grammar.Boolean_ x)) SBOOL) )
    | %try SSTRING => ( Grammar.Sample (List.map (fn(x) => Grammar.Primitivo(Grammar.String_ x)) SSTRING) )
    ;
prints
   :  KW_Print LP STR RP SEMI => ( ps := (STR::(!ps)))
   |  KW_Print LP ID RP SEMI => (
        let 
            val k = Grammar.show (valOf (AtomMap.find (!v, Atom.atom ID)))
        in 
            ps := k::(!ps)
        end
      ) 
   ;
funcs_string
    : KW_TOSTRING LP expr RP => (Grammar.show expr)
    ;
funcs_float
    : KW_SUM LP EMPTY RP  => ( 0.0)
    | KW_SUM LP float_list RP  
        => (List.foldl op+ 0.0 float_list)
    | KW_PROD LP EMPTY RP  => (0.0)
    | KW_PROD LP float_list RP 
        => (List.foldl op* 1.0 float_list)
    | KW_MEAN LP float_list RP => (Statistics.mean float_list)
    | KW_CORR LP float_list COMMA float_list RP => (Statistics.correlation(float_list1, float_list2))
    ;
float_list
    : ID => (List.map getFloat (getList (valOf(AtomMap.find (!v, Atom.atom ID))))) 
    | SFLOAT => (SFLOAT)
    ;
exp_bool
    : %try exp_arit EEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("==",exp_arit1,exp_arit2))
    | %try exp_arit NEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("!=",exp_arit1,exp_arit2))
    | %try exp_arit LEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("<=",exp_arit1,exp_arit2))
    | %try exp_arit GEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper(">=",exp_arit1,exp_arit2))
    | %try exp_arit LT exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("<",exp_arit1,exp_arit2))
    | %try exp_arit GT exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper(">",exp_arit1,exp_arit2))
    | %try atom_bool AND atom_bool %where (exprTypes atom_bool1 atom_bool2) => ((Grammar.Primitivo(Grammar.Boolean_((getBool atom_bool1) andalso (getBool atom_bool2)))))
    | %try atom_bool OR atom_bool %where (exprTypes atom_bool1 atom_bool2) => ((Grammar.Primitivo(Grammar.Boolean_((getBool atom_bool1) orelse (getBool atom_bool2)))))
    | %try NOT atom_bool %where (isType atom_bool "bool") => ((Grammar.Primitivo(Grammar.Boolean_(not ((getBool atom_bool))))) )
    | %try atom_bool
    ;    
atom_bool
    : BOOL => (Grammar.Primitivo (Grammar.Boolean_ BOOL))
    | LP exp_bool RP
    | ID => (valOf(AtomMap.find (!v, Atom.atom ID))) 
    ;
conditional
    : KW_IF exp_bool block@(getBool exp_bool) => ()
    ;
block(b)
    : %try KW_THEN commands => (if b then commands else ())
    | %try KW_THEN commands else_block@(b) => (if b then commands else else_block)
    ;
else_block(b)
    : KW_ELSE commands 
    ;
exp_arit
    : %try addExp 
    | %try atomicExp
    ;
addExp
    : %try multExp PLUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("+",multExp1,multExp2))
    | %try multExp MINUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("-",multExp1,multExp2))
    | %try multExp
    ;
multExp
    : %try prefixExp DIV prefixExp %where ((isType prefixExp1 "float") andalso (isType prefixExp2 "float") andalso (exprTypes prefixExp1 prefixExp2)) 
        => ( Grammar.oper("/",prefixExp1,prefixExp2) )
    | %try prefixExp TIMES prefixExp %where (exprTypes prefixExp1 prefixExp2) 
        => ( Grammar.oper("*",prefixExp1,prefixExp2) )
    | %try atomicExp
    ;
prefixExp
    : atomicExp
    | "-" prefixExp
        => ( Grammar.oper("neg",prefixExp,prefixExp) )
    ;
atomicExp
    : ID => (valOf(AtomMap.find (!v, Atom.atom ID))) 
    | NUM => (Grammar.Primitivo (Grammar.Int_ NUM))
    | REAL => (Grammar.Primitivo (Grammar.Float_ REAL))
    | "(" exp_arit ")"
    ;
variables
    : (declaration)* KW_endvars => ((fn(_) => ()) SR)
    ;
declaration
    : TIPO ID SEMI => (v:=insere(!v,Atom.atom ID,Atom.toString(Atom.atom TIPO));
                       ts:=AtomMap.insert(!ts,Atom.atom ID,TIPO))
    ;