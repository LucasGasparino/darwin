%name Darwin;

%defs (
    fun insere(hm,n,"int") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Int_ 0))
      | insere(hm,n,"string") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.String_ ""))
      | insere(hm,n,"float") = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Float_ 0.0))
      | insere(hm,n,_) = AtomMap.insert(hm, n, Grammar.Primitivo(Grammar.Boolean_ false))
    
    fun getInt x = (Grammar.extractInt x)
    fun getFloat x = (Grammar.extractFloat x)
    fun getBool x = (Grammar.extractBool x)
    
    fun exprTypes e1 e2 = (Grammar.typeof e1) = (Grammar.typeof e2)
    fun isType e1 t = (Grammar.typeof e1) = t
    
    fun getVar v = AtomMap.appi (fn (k,w) => print (
        let val _ = print(Atom.toString k) 
            val _ = "oi"
            val _ = print (Grammar.show w)
        in 
            ""
        end)) v
);

%tokens
    : KW_let ("let") | KW_in ("in") | KW_title ("title") 
    | ID of string | NUM of Int.int | REAL of Real.real
    | EQ ("=") | PLUS ("+") | DOT (".") | EEQ ("==")
    | TIMES ("*") | DIV("/") | MINUS ("-")
    | LP ("(") | RP (")") | BOOL of bool | AND ("&&") | OR ("||") | NOT("!")
    | SPACE (" ") | GT(">") | LT("<") | LEQ("<=") | GEQ(">=") | NEQ("!=")
    | KW_variables ("variables") | SEMI | TIPO of string
    | KW_comands ("commands") | STR of string | KW_Print ("print")
    | KW_endvars ("end variables") | KW_terminate ("terminate")
    ;
%keywords
    KW_variables,
    KW_title,
    KW_comands,
    KW_endvars,
    KW_terminate
    ;

%refcell v : (Grammar.tipo) AtomMap.map = (AtomMap.empty);
%refcell ps : string list = (nil);

program(d)
    : KW_title STR SEMI
      KW_variables
      variables
      KW_comands
      commands => ()
    ;
commands
    : (prints | assign)*  => ((fn(_) => ()) SR)   
    ;
assign
    : ID EQ expr SEMI => (v := Grammar.updateHt(!v,Atom.atom ID,expr))
    ;
expr
    : %try exp_arit => (exp_arit)
    | %try exp_bool => (exp_bool)
    ;
prints
   :  KW_Print LP STR RP SEMI => ( ps := (STR::(!ps)) )
   |  KW_Print LP ID RP SEMI => (
        let 
            val k = Grammar.show (valOf (AtomMap.find (!v, Atom.atom ID)))
        in 
            ps := k::(!ps)
        end
      ) 
   ;
exp_bool
    : %try exp_arit EEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("==",exp_arit1,exp_arit2))
    | %try exp_arit NEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("!=",exp_arit1,exp_arit2))
    | %try exp_arit LEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("<=",exp_arit1,exp_arit2))
    | %try exp_arit GEQ exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper(">=",exp_arit1,exp_arit2))
    | %try exp_arit LT exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper("<",exp_arit1,exp_arit2))
    | %try exp_arit GT exp_arit %where (exprTypes exp_arit1 exp_arit2) => (Grammar.oper(">",exp_arit1,exp_arit2))
    | %try atom_bool AND atom_bool %where (exprTypes atom_bool1 atom_bool2) => ((Grammar.Primitivo(Grammar.Boolean_((getBool atom_bool1) andalso (getBool atom_bool2)))))
    | %try atom_bool OR atom_bool %where (exprTypes atom_bool1 atom_bool2) => ((Grammar.Primitivo(Grammar.Boolean_((getBool atom_bool1) orelse (getBool atom_bool2)))))
    | %try NOT atom_bool %where (isType atom_bool "bool") => ((Grammar.Primitivo(Grammar.Boolean_(not ((getBool atom_bool))))) )
    | %try atom_bool
    ;    
atom_bool
    : BOOL => (Grammar.Primitivo (Grammar.Boolean_ BOOL))
    | LP exp_bool RP
    | ID => (valOf(AtomMap.find (!v, Atom.atom ID))) 
    ;
exp_arit
    : %try addExp 
    | %try atomicExp
    ;
addExp
    : %try multExp PLUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("+",multExp1,multExp2))
    | %try multExp MINUS multExp %where (exprTypes multExp1 multExp2) => (Grammar.oper("-",multExp1,multExp2))
    | %try multExp
    ;
multExp
    : %try prefixExp DIV prefixExp %where ((isType prefixExp1 "float") andalso (isType prefixExp2 "float") andalso (exprTypes prefixExp1 prefixExp2)) 
        => ( Grammar.oper("/",prefixExp1,prefixExp2) )
    | %try prefixExp TIMES prefixExp %where (exprTypes prefixExp1 prefixExp2) 
        => ( Grammar.oper("*",prefixExp1,prefixExp2) )
    | %try atomicExp
    ;
prefixExp
    : atomicExp
    | "-" prefixExp
        => ( Grammar.oper("neg",prefixExp,prefixExp) )
    ;
atomicExp
    : ID => (valOf(AtomMap.find (!v, Atom.atom ID))) 
    | NUM => (Grammar.Primitivo (Grammar.Int_ NUM))
    | REAL => (Grammar.Primitivo (Grammar.Float_ REAL))
    | "(" exp_arit ")"
    ;
variables
    : (declaration)* KW_endvars => ((fn(_) => ()) SR)
    ;
declaration
    : TIPO ID SEMI => (v:=insere(!v,Atom.atom ID,Atom.toString(Atom.atom TIPO)))
    ;